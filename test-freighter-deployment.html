<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Freighter Deployment Test</title>
    <script src="https://unpkg.com/@stellar/stellar-sdk@14.0.0-rc.3/dist/stellar-sdk.min.js"></script>
    <script src="https://unpkg.com/@stellar/freighter-api@1.7.1/dist/index.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .button { padding: 10px 20px; margin: 5px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .button:hover { background: #45a049; }
        .button:disabled { background: #cccccc; cursor: not-allowed; }
        .log { background: #f9f9f9; padding: 10px; border-radius: 4px; margin: 10px 0; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .warning { color: orange; }
        .status { padding: 5px 10px; border-radius: 3px; margin: 5px 0; display: inline-block; }
        .status.connected { background: #d4edda; color: #155724; }
        .status.disconnected { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>🧪 Freighter Contract Deployment Test</h1>
    <p>This test will deploy our SEP-41 contract using Freighter to compare with SAFU wallet approach.</p>

    <!-- Connection Status -->
    <div class="section">
        <h2>📡 Connection Status</h2>
        <div id="connectionStatus" class="status disconnected">Disconnected</div>
        <div id="accountInfo"></div>
        <button class="button" onclick="connectFreighter()">Connect to Freighter</button>
        <button class="button" onclick="checkConnection()">Check Connection</button>
    </div>

    <!-- Contract Deployment -->
    <div class="section">
        <h2>🚀 Contract Deployment</h2>
        <p><strong>Network:</strong> Futurenet</p>
        <p><strong>Contract:</strong> SEP-41 Token (same as used with SAFU)</p>
        
        <button class="button" onclick="deployContract()" id="deployBtn">Deploy Contract</button>
        <button class="button" onclick="downloadTransactionXDR()" id="downloadBtn" disabled>Download Transaction XDR</button>
        
        <div id="deploymentResults"></div>
    </div>

    <!-- Transaction Log -->
    <div class="section">
        <h2>📋 Transaction Log</h2>
        <button class="button" onclick="clearLog()">Clear Log</button>
        <div id="log" class="log"></div>
    </div>

    <script>
        // Configuration
        const FUTURENET_CONFIG = {
            networkPassphrase: StellarSdk.Networks.FUTURENET,
            sorobanRpcUrl: 'https://rpc-futurenet.stellar.org'
        };

        let server = new StellarSdk.rpc.Server(FUTURENET_CONFIG.sorobanRpcUrl);
        let connectedAccount = null;
        let lastTransactionXDR = null;
        let lastDeploymentResult = null;

        // SEP-41 WASM (base64 encoded - our exact contract)
        const SEP41_WASM_BASE64 = `AGFzbQEAAAABLAhgAX8AYAAAYAF/AX9gAn9/AGACf38Bf2ADf39/AGADf39/AX9gBH9/f38AAgwBAWwBMAAAAQAAAwsKAAECAwQFBgcHBAAEBQFwAQEBBQMBAAEGCQF/AUGAgMAAC2daDDxpbnN0cnVjdGlvbj48aW5zdHJ1Y3Rpb24+AXYTaW5pdGlhbGl6ZV90YWJsZQEAAVsDaW5zdHJ1Y3Rpb24+PGluc3RydWN0aW9uPgAQX19zdGFja19wb2ludGVyBAABLgQAQYCAwAALJwEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAEBCvkDCgUAQQALxgJuYW1lAABAAYICNwAAAAl0b2tlbi5yczAAAAAOdG9rZW5fc2VjdXJpdHkwCWluaXRpYWxpemUxCG5hbWVfc2VjMgdzeW1ib2wuM2RlY2ltYWxzNAh0b3RhbF9zdXBwbHk1B2JhbGFuY2U2BG1pbnQ3CHRyYW5zZmVyOAplbmRfa2V5X2hhc2g5CWNhbGxfc2VjdGlvbjEwEmFsbGV3YW5jZV9wcm92aWRlcjExDAAxEg==`;

        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function updateConnectionStatus(connected, account = null) {
            const statusElement = document.getElementById('connectionStatus');
            const accountInfo = document.getElementById('accountInfo');
            
            if (connected && account) {
                statusElement.className = 'status connected';
                statusElement.textContent = 'Connected';
                accountInfo.innerHTML = `<strong>Account:</strong> ${account}`;
                connectedAccount = account;
                log(`Connected to Freighter: ${account}`, 'success');
            } else {
                statusElement.className = 'status disconnected';
                statusElement.textContent = 'Disconnected';
                accountInfo.innerHTML = '';
                connectedAccount = null;
                log('Disconnected from Freighter', 'warning');
            }
        }

        // Freighter connection functions
        async function connectFreighter() {
            try {
                log('Attempting to connect to Freighter...', 'info');
                
                const isAllowed = await window.freighterApi.isAllowed();
                if (!isAllowed) {
                    log('Requesting access to Freighter...', 'info');
                    await window.freighterApi.requestAccess();
                }

                const { address } = await window.freighterApi.getAddress({
                    networkPassphrase: FUTURENET_CONFIG.networkPassphrase
                });

                updateConnectionStatus(true, address);
                
                // Check if account is funded
                try {
                    const account = await server.getAccount(address);
                    log(`Account found with sequence: ${account.sequenceNumber()}`, 'success');
                } catch (e) {
                    log(`Account not found or not funded: ${e.message}`, 'error');
                }

            } catch (error) {
                log(`Freighter connection failed: ${error.message}`, 'error');
                updateConnectionStatus(false);
            }
        }

        async function checkConnection() {
            try {
                const isConnected = await window.freighterApi.isConnected();
                if (isConnected) {
                    const { address } = await window.freighterApi.getAddress({
                        networkPassphrase: FUTURENET_CONFIG.networkPassphrase
                    });
                    updateConnectionStatus(true, address);
                } else {
                    updateConnectionStatus(false);
                }
            } catch (error) {
                log(`Connection check failed: ${error.message}`, 'error');
                updateConnectionStatus(false);
            }
        }

        // Contract deployment functions
        async function deployContract() {
            if (!connectedAccount) {
                log('Please connect to Freighter first', 'error');
                return;
            }

            const deployBtn = document.getElementById('deployBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            deployBtn.disabled = true;
            deployBtn.textContent = 'Deploying...';

            try {
                log('Starting contract deployment...', 'info');

                // Step 1: Upload WASM
                log('Step 1: Uploading WASM...', 'info');
                const wasmHash = await uploadWASM();
                log(`WASM uploaded successfully: ${wasmHash}`, 'success');

                // Step 2: Create contract instance
                log('Step 2: Creating contract instance...', 'info');
                const contractAddress = await createContract(wasmHash);
                log(`Contract deployed successfully: ${contractAddress}`, 'success');

                // Step 3: Initialize contract
                log('Step 3: Initializing contract...', 'info');
                await initializeContract(contractAddress);
                log('Contract initialized successfully', 'success');

                // Show results
                const resultsDiv = document.getElementById('deploymentResults');
                resultsDiv.innerHTML = `
                    <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <h3 style="margin: 0 0 10px 0; color: #155724;">✅ Deployment Successful!</h3>
                        <p><strong>WASM Hash:</strong> <code>${wasmHash}</code></p>
                        <p><strong>Contract Address:</strong> <code>${contractAddress}</code></p>
                        <p><strong>Admin:</strong> <code>${connectedAccount}</code></p>
                        <p><strong>Network:</strong> Futurenet</p>
                        <p><a href="https://futurenet.steexp.com/contract/${contractAddress}" target="_blank">View on Explorer</a></p>
                    </div>
                `;

                downloadBtn.disabled = false;
                log('🎉 Complete deployment successful!', 'success');

            } catch (error) {
                log(`Deployment failed: ${error.message}`, 'error');
                console.error('Full deployment error:', error);
                
                const resultsDiv = document.getElementById('deploymentResults');
                resultsDiv.innerHTML = `
                    <div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <h3 style="margin: 0 0 10px 0; color: #721c24;">❌ Deployment Failed</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                    </div>
                `;
            } finally {
                deployBtn.disabled = false;
                deployBtn.textContent = 'Deploy Contract';
            }
        }

        async function uploadWASM() {
            const wasmBuffer = Uint8Array.from(atob(SEP41_WASM_BASE64), c => c.charCodeAt(0));
            log(`Loaded WASM: ${wasmBuffer.length} bytes`, 'info');

            const sourceAccount = await server.getAccount(connectedAccount);
            log(`Source account sequence: ${sourceAccount.sequenceNumber()}`, 'info');

            // Create upload operation
            const uploadOp = StellarSdk.Operation.uploadContractWasm({
                wasm: wasmBuffer,
            });

            // Build transaction
            let uploadTx = new StellarSdk.TransactionBuilder(sourceAccount, {
                fee: (StellarSdk.BASE_FEE * 200000).toString(),
                networkPassphrase: FUTURENET_CONFIG.networkPassphrase,
            })
            .addOperation(uploadOp)
            .setTimeout(300)
            .build();

            log('Preparing transaction with Soroban RPC...', 'info');
            uploadTx = await server.prepareTransaction(uploadTx);
            const uploadTxXdr = uploadTx.toXDR();
            lastTransactionXDR = uploadTxXdr;

            log('Requesting signature from Freighter...', 'info');
            const { signedTxXdr } = await window.freighterApi.signTransaction(uploadTxXdr, {
                networkPassphrase: FUTURENET_CONFIG.networkPassphrase
            });

            log('Transaction signed, submitting to network...', 'info');
            const signedTx = StellarSdk.TransactionBuilder.fromXDR(signedTxXdr, FUTURENET_CONFIG.networkPassphrase);
            let uploadResult = await server.sendTransaction(signedTx);

            log(`Upload status: ${uploadResult.status}`, 'info');

            if (uploadResult.status === 'PENDING') {
                log('Waiting for confirmation...', 'info');
                uploadResult = await waitForTransaction(uploadResult.txHash, 'WASM upload');
            }

            if (uploadResult.status !== 'SUCCESS') {
                throw new Error(`WASM upload failed: ${uploadResult.status}`);
            }

            // Return transaction hash as WASM identifier
            return uploadResult.txHash;
        }

        async function createContract(wasmHash) {
            const sourceAccount = await server.getAccount(connectedAccount);

            // Create contract deployment operation
            const deployOp = StellarSdk.Operation.createCustomContract({
                address: StellarSdk.Address.fromString(connectedAccount),
                wasmHash: Buffer.from(wasmHash, 'hex'),
                salt: Buffer.alloc(32) // Deterministic salt
            });

            // Build transaction
            let deployTx = new StellarSdk.TransactionBuilder(sourceAccount, {
                fee: (StellarSdk.BASE_FEE * 50000).toString(),
                networkPassphrase: FUTURENET_CONFIG.networkPassphrase,
            })
            .addOperation(deployOp)
            .setTimeout(300)
            .build();

            log('Preparing contract deployment transaction...', 'info');
            deployTx = await server.prepareTransaction(deployTx);
            const deployTxXdr = deployTx.toXDR();

            log('Requesting signature from Freighter...', 'info');
            const { signedTxXdr } = await window.freighterApi.signTransaction(deployTxXdr, {
                networkPassphrase: FUTURENET_CONFIG.networkPassphrase
            });

            log('Transaction signed, submitting to network...', 'info');
            const signedTx = StellarSdk.TransactionBuilder.fromXDR(signedTxXdr, FUTURENET_CONFIG.networkPassphrase);
            let deployResult = await server.sendTransaction(signedTx);

            log(`Deploy status: ${deployResult.status}`, 'info');

            if (deployResult.status === 'PENDING') {
                log('Waiting for confirmation...', 'info');
                deployResult = await waitForTransaction(deployResult.txHash, 'contract deployment');
            }

            if (deployResult.status !== 'SUCCESS') {
                throw new Error(`Contract deployment failed: ${deployResult.status}`);
            }

            // Extract contract address
            if (deployResult.returnValue) {
                return StellarSdk.Address.fromScVal(deployResult.returnValue).toString();
            }

            throw new Error('No contract address returned');
        }

        async function initializeContract(contractAddress) {
            const contract = new StellarSdk.Contract(contractAddress);
            const sourceAccount = await server.getAccount(connectedAccount);

            // Initialize with Freighter account as admin
            const initOp = contract.call(
                'initialize',
                StellarSdk.nativeToScVal(StellarSdk.Address.fromString(connectedAccount), { type: 'address' }),
                StellarSdk.nativeToScVal(7, { type: 'u32' }),
                StellarSdk.nativeToScVal('Freighter Token', { type: 'string' }),
                StellarSdk.nativeToScVal('FREIGHT', { type: 'string' })
            );

            // Build transaction
            let initTx = new StellarSdk.TransactionBuilder(sourceAccount, {
                fee: (StellarSdk.BASE_FEE * 10000).toString(),
                networkPassphrase: FUTURENET_CONFIG.networkPassphrase,
            })
            .addOperation(initOp)
            .setTimeout(300)
            .build();

            log('Preparing initialization transaction...', 'info');
            initTx = await server.prepareTransaction(initTx);
            const initTxXdr = initTx.toXDR();

            log('Requesting signature from Freighter...', 'info');
            const { signedTxXdr } = await window.freighterApi.signTransaction(initTxXdr, {
                networkPassphrase: FUTURENET_CONFIG.networkPassphrase
            });

            log('Transaction signed, submitting to network...', 'info');
            const signedTx = StellarSdk.TransactionBuilder.fromXDR(signedTxXdr, FUTURENET_CONFIG.networkPassphrase);
            let initResult = await server.sendTransaction(signedTx);

            log(`Initialize status: ${initResult.status}`, 'info');

            if (initResult.status === 'PENDING') {
                log('Waiting for confirmation...', 'info');
                initResult = await waitForTransaction(initResult.txHash, 'token initialization');
            }

            if (initResult.status !== 'SUCCESS') {
                throw new Error(`Token initialization failed: ${initResult.status}`);
            }

            return initResult;
        }

        async function waitForTransaction(txHash, description) {
            log(`Waiting for ${description} confirmation...`, 'info');
            
            for (let i = 0; i < 30; i++) {
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                try {
                    const result = await server.getTransaction(txHash);
                    log(`Check ${i + 1}/30: ${result.status}`, 'info');
                    
                    if (result.status === 'SUCCESS') {
                        log(`${description} confirmed!`, 'success');
                        return result;
                    } else if (result.status === 'FAILED') {
                        log(`${description} failed:`, 'error');
                        throw new Error(`${description} failed`);
                    }
                } catch (e) {
                    log(`Still waiting... (${i + 1}/30)`, 'info');
                }
            }
            
            throw new Error(`${description} timeout after 90 seconds`);
        }

        function downloadTransactionXDR() {
            if (!lastTransactionXDR) {
                log('No transaction XDR available', 'error');
                return;
            }

            const blob = new Blob([lastTransactionXDR], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'freighter-deployment-transaction.xdr';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('Transaction XDR downloaded', 'success');
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            log('Page loaded, checking Freighter availability...', 'info');
            
            if (window.freighterApi) {
                log('Freighter API detected', 'success');
                checkConnection();
            } else {
                log('Freighter not detected. Please install Freighter extension.', 'error');
            }
        });
    </script>
</body>
</html>